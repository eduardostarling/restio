# Strategies

> NOTICE: Some of the terms utilized in this page are described under [the framework description page](FRAMEWORK.md). Please refer to it before proceeding.

This page explains the internal mechanisms of *restio*, and describes some of the design decisions made during implementation. In general, most of the items below are managed by **Transaction** instances separately:

- Model uniqueness
- Caching
- Model State Management
- Commit and Rollback


## Model uniqueness

In *restio*, a model instance (from now on referred as `model` for simplicity) represents one object (to be) persisted in a remote data store through a REST API. To keep track of models representing the same data on the remote, *restio* identifies each of them uniquely by their *primary keys* and *internal UUID*.

The fields that represent the *primary keys* are statically defined by providing the descriptor `pk` when declaring model classes, and are loaded when retrieving the models from the remote server. In general, all models will have their primary key fields populated when retrieving data from the remote server. It is up to the developer to choose the *primary keys* that will identify a model. A few things to keep in mind:

- Depending on the remote REST API, some primary keys cannot be defined by the client and will be generated by the server when creating the model. In the meantime, the models will be identified by their *internal UUID* that is automatically generated when instantiating the model. In this case, it is up to the DAO to propagate this value back to the model.
- When calling `Transaction.get(ModelType, primary_keys)`, transaction instances will propagate the request to DAOs for retrieving models from the remote if they don't exist in cache yet. The values in the `primary_keys` tuple will dictate the search in cache that happens before this call, so keep this in mind when choosing the fields that will truly behave as identifies (see Caching below for more details).
- Primary keys will be organized in order of declaration in the model class.

> WARNING: Currently, models that change primary keys in runtime will need to be registered in cache again. This is a temporary limitation and will be fixed on the incoming versions.


## Caching

Every **Transaction** contains its own internal cache. The cache is composed by two in-memory data stores:

- Model Cache
- Query Cache

The *Model Cache* is the ultimate source of truth for storing values in the *Transaction*. Every model retrieved from `Transaction.get` and `Transaction.query`, or passed to `Transaction.add` is registered in the *Model Cache* (if it is not there yet). A model can be identified in the *Model Cache* by either its *primary keys* or its *internal UUID*.

On the other hand, the *Query Cache* is a secondary mechanism to optimize the interaction with the remote API that would in most cases happen via multiple calls to `Transaction.get`. Cached queries always hold references to models registered in the *Model Cache* and don't depend on the involved primary keys. Queries are identified by their instance types and the parameters provided.

The transaction cache is valid while the transaction instance exists. To eliminate the cache, the developer can either dispose from it, start a new one, or call `Transaction.reset()`.

Possible inconsistencies between values retrieved from the remote and the local cache will cause the transaction to ignore the incoming data and favor the locally stored models. This is done to guarantee atomicity of operations within the transaction scope. It is up to the developer to define the consistency boundaries of the application and create a workflow that will reduce the chance of overriding data on the remote server.

## Model State Management

Each model in a transaction contains an internal state. When calling `Transaction.commit()` or `Transaction.rollback()` (see details below on the section Commit and Rollback), the transaction uses the state of the models to decide how to propagate data to the remote server.

Below, a list of possible states a model can hold:

| State     | Description |
| --------- | ----------- |
| CLEAN     | The model has been retrieved from the remote and has not been modified locally. |
| NEW       | The model has been instantiated locally and marked in the transaction to be added during commit. |
| DIRTY     | The model has been retrieved from the remote and has been modified locally. |
| DELETED   | The model has been retrieved from the remote and has been marked for deletion. |
| DISCARDED | The model has been registered in the internal cache and marked to be discarded. |

The transaction is resposible for coordinating the state of each model in its cache. Each model is either marked as **CLEAN** (when retrieved from the remote server through `Transaction.get` or `Transaction.query`) or **NEW** (when marked for adding through `Transaction.add`) when provided to the transaction for the first time. Subsequent operations to the model will either cause its state to change to **DIRTY** (when the value of at least one model field changes when compared to persistent values), **DELETED** (when marked for deletion) or **DISCARDED** (when marked for deletion after adding, or when deleted during `Transaction.commit()`).

> WARNING: Models with fields containing mutable collections (lists or sets) will not automatically be marked as **DIRTY** if items get added, removed or reordered. This is a know limitation that should be handled by the developer with specialized methods on model level for re-assigning new collections after modification. This should change in the future.

### Model data

Each model will store two sets of data internally.

- The first set contains the actual values of the models. These values can be retrieved and modified normally by accessing the fields of the instance.
- The second set stores the persistent values for each modified field, so it is possible to evaluate the overall state of a model after each change. This also makes it possible to rollback models to their previous persistent state.

On the BLL, the developer will most likely only need to access the regular fields of the models. However, in `DAO.update` it might be handy to check which fields changed by accessing the `model._persistent_values` attribute. By doing that, the developer is able to:

- Efficiently select fewer endpoints for modifying each model based on the changed fields.
- Reduce the chance of data inconsistency when persisting changes to the remote API.

## Commit and Rollback

Commit and Rollback rely on the state of each model for decision making. Below, a description of how they work.

### Commit

Models are persisted to the remote data store during `commit`. The **Transaction** will try to schedule as many `asyncio` tasks as possible to optimize the calls to the remote server - this is done to reduce the total time to commit all models.

The logic for deciding the order in which models are persisted is the following:

1. Models are filtered in three groups according to their stat (`NEW`, `DIRTY` and `DELETED`).

2. The models in any of the graphs are inspected to make sure there is one DAO associated to each model. There is no check for DAO function overriding.

3. Models on the third graph are inspected one-by-one. If any of these models contain at least one cached parent pointing to it that will still be persisted on the remote data store (in other words, parents that will not be deleted), then the commit is interrupted.

4. Three dependencies graphs are drawn. The first graph include only models with state `NEW`, the second only with models with state `DIRTY` and the third only with models with state `DELETED`. On all graphs, the parents of a model are the models referring to it, while the children are the models referred by it.

5. The graphs are processed in order. The trees in `NEW` and `DIRTY` graphs are traversed from top to bottom (parents to children), while in the `DELETED` graph the trees are traversed from bottom to top (children to parents). All operations from one graph need to be finalized so the next graph can be processed. Operations within each graph are optimized as follows:

  - All trees in a graph are processed in parallel in the `asyncio` event loop.
  - Each group of nodes are scheduled in parallel in the `asyncio` event loop.
  - As soon as a node is processed, the next node(s) is (are) scheduled to be persisted if the tree structure   allows (that means, if all children of a particular node have been processed, that node can be processed).   Otherwise, the processor awaits until a new node is processed, and the inspection for a new node restarts.
  - If an error occurs, the processing will bexception_queuee conditioned to the `PersistencyStrategy` defined for the   transaction. This should be set per transaction scope and the choice might vary according to the use case:
    - `INTERRUPT_ON_ERROR` will cause the commit to interrupt the scheduling of new nodes and will wait until current processes finalize.
    - `CONTINUE_ON_ERROR` will cause the commit to ignore the error messages and continue processing all available nodes.
  - Models that have been persisted on the remote will be also persisted on the local cache, while models not   processed or processed with error are not persisted on cache. This behavior does not depend on the   `PersistencyStrategy`. Models that have been deleted will be discarded from cache.

6. If any error occured, a `TransactionError` will be thrown containing a queue with all errors caught, and a   queue with all models that have been processed correctly.

### Rollback

Rollbacks do not affect the data on the remote data store. The term is here used for rolling back changes on the internal cache that have not yet been persisted on the remote. This is particularly useful if a certain business rule is violated but the developer still wants to utilize the values from the cache without requesting for the whole data again.

Rolling back will behave as follows:

- Models marked as `NEW` and `DELETED` will be marked as `DISCARDED`.
- Models marked as `DIRTY` will be reverted to `CLEAN` and the persistent internal values recovered.
- All `DISCARDED` models are removed from the cache.