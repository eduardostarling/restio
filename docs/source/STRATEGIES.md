# Strategies

> NOTICE: Some of the terms utilized in this page are described under [the framework description page](FRAMEWORK.md). Please refer to it before proceeding.

This page explains the internal mechanisms of *restio*, and explains some of the design decisions made during implementation. In general, most (if not all) of the items below are managed by **Transaction** instances separately:

- Model uniqueness
- Caching
- Model State Management
- Commit and Rollback


## Model uniqueness

In *restio*, a model instance (from now on referred as `model` for simplicity) represents one object (to be) persisted in a remote data store through a REST API. To keep track of models representing the same data on the remote, *restio* identifies each of them uniquely by their *primary keys* and *internal UUID*.

The fields that represent the *primary keys* are statically defined by providing the descriptor `pk` when declaring model classes, and are loaded when retrieving the models from the remote server. In general, all models will have their primary key fields populated when retrieving data from the remote server. It is up to the developer to choose the *primary keys* that will identify a model. A few things to keep in mind:

- Depending on the remote REST API, some primary keys cannot be defined by the client and will be generated by the server when creating the model. In the meantime, the models will be identified by their *internal UUID* that is automatically generated when instantiating the model. In this case, it is up to the DAO to propagate this value back to the model.
- When calling `Transaction.get(ModelType, primary_keys)`, transaction instances will propagate the request to DAOs for retrieving models from the remote if they don't exist in cache yet. The values in the `primary_keys` tuple will dictate the search in cache that happens before this call, so keep this in mind when choosing the fields that will truly behave as identifies (see Caching below for more details).
- Primary keys will be organized in order of declaration in the model class.

> WARNING: Currently, models that change primary keys in runtime will need to be registered in cache again. This is a temporary limitation and will be fixed on the incoming versions.


## Caching

Every **Transaction** contains its own internal cache. The cache is composed by two in-memory data stores:

- Model Cache
- Query Cache

The *Model Cache* is the ultimate source of truth for storing values in the *Transaction*. Every model retrieved from `Transaction.get` and `Transaction.query`, or passed to `Transaction.add` is registered in the *Model Cache* (if it is not there yet). A model can be identified in the *Model Cache* by either its *primary keys* or its *internal UUID*.

On the other hand, the *Query Cache* is a secondary mechanism to optimize the interaction with the remote API that would in most cases happen via multiple calls to `Transaction.get`. Cached queries always hold references to models registered in the *Model Cache* and don't depend on the involved primary keys. Queries are identified by their instance types and the parameters provided.

The transaction cache is valid while the transaction instance exists. To eliminate the cache, the developer can either dispose from it, start a new one, or call `Transaction.reset()`.

Possible inconsistencies between values retrieved from the remote and the local cache will cause the transaction to ignore the incoming data and favor the locally stored models. This is done to guarantee atomicity of operations within the transaction scope. It is up to the developer to define the consistency boundaries of the application and create a workflow that will reduce the chance of overriding data on the remote server.

## Model State Management

Each model in a transaction contains an internal state. When calling `Transaction.commit()` or `Transaction.rollback()` (see details below on the section Commit and Rollback), the transaction uses the state of the models to decide how to propagate data to the remote server.

Below, a list of possible states a model can hold:

| State     | Description |
| --------- | ----------- |
| CLEAN     | The model has been retrieved from the remote and has not been modified locally. |
| NEW       | The model has been instantiated locally and marked in the transaction to be added during commit. |
| DIRTY     | The model has been retrieved from the remote and has been modified locally. |
| DELETED   | The model has been retrieved from the remote and has been marked for deletion. |
| DISCARDED | The model has been registered in the internal cache and marked to be discarded. |

The transaction is resposible for coordinating the state of each model in its cache. Each model is either marked as **CLEAN** (when retrieved from the remote server through `Transaction.get` or `Transaction.query`) or **NEW** (when marked for adding through `Transaction.add`) when provided to the transaction for the first time. Subsequent operations to the model will either cause its state to change to **DIRTY** (when the value of at least one model field changes when compared to persistent values), **DELETED** (when marked for deletion) or **DISCARDED** (when marked for deletion after adding, or when deleted during `Transaction.commit()`).

> WARNING: Models with fields containing mutable collections (lists or sets) will not automatically be marked as **DIRTY** if items get added, removed or reordered. This is a know limitation that should be handled by the developer with specialized methods on model level for re-assigning new collections after modification. This should change in the future.

### Model data

Each model will store two sets of data internally.

- The first set contains the actual values of the models. These values can be retrieved and modified normally by accessing the fields of the instance.
- The second set stores the persistent values for each modified field, so it is possible to evaluate the overall state of a model after each change. This also makes it possible to rollback models to their previous persistent state.

On the BLL, the developer will most likely only need to access the regular fields of the models. However, in `DAO.update` it might be handy to check which fields changed by accessing the `model._persistent_values` attribute. By doing that, the developer is able to:

- Efficiently select fewer endpoints for modifying each model based on the changed fields.
- Reduce the chance of data inconsistency when persisting changes to the remote API.

## Commit and Rollback

TODO